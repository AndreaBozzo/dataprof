use crate::analysis::MlReadinessScore;
use crate::core::batch::{BatchResult, BatchSummary};
use crate::types::{ColumnProfile, ColumnStats, DataType, QualityIssue, QualityReport, Severity};
use anyhow::Result;
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};

pub fn generate_html_report(report: &QualityReport, output_path: &Path) -> Result<()> {
    let html_content = build_html(report);
    fs::write(output_path, html_content)?;
    Ok(())
}

fn build_html(report: &QualityReport) -> String {
    format!(
        r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataProfiler Report - {}</title>
    <style>
        {}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìä DataProfiler Report</h1>
            <div class="file-info">
                <h2>{}</h2>
                <div class="stats-grid">
                    <div class="stat">
                        <span class="label">File Size</span>
                        <span class="value">{:.1} MB</span>
                    </div>
                    <div class="stat">
                        <span class="label">Total Rows</span>
                        <span class="value">{}</span>
                    </div>
                    <div class="stat">
                        <span class="label">Columns</span>
                        <span class="value">{}</span>
                    </div>
                    <div class="stat">
                        <span class="label">Scan Time</span>
                        <span class="value">{} ms</span>
                    </div>
                </div>
                {}
            </div>
        </header>

        {}

        <section class="columns">
            <h2>üìà Column Analysis</h2>
            <div class="columns-grid">
                {}
            </div>
        </section>

        <footer>
            <p>Generated by <strong>DataProfiler CLI</strong> v0.2.0</p>
        </footer>
    </div>
</body>
</html>"#,
        Path::new(&report.file_info.path)
            .file_name()
            .unwrap_or_default()
            .to_string_lossy(),
        get_css(),
        report.file_info.path,
        report.file_info.file_size_mb,
        report
            .file_info
            .total_rows
            .map_or("Unknown".to_string(), |r| r.to_string()),
        report.file_info.total_columns,
        report.scan_info.scan_time_ms,
        build_sampling_info(&report.scan_info),
        build_quality_section(&report.issues),
        build_columns_section(&report.column_profiles)
    )
}

fn build_sampling_info(scan_info: &crate::types::ScanInfo) -> String {
    if scan_info.sampling_ratio < 1.0 {
        format!(
            r#"<div class="sampling-info">
                <span class="sampling-badge">Sampled {} rows ({:.1}%)</span>
            </div>"#,
            scan_info.rows_scanned,
            scan_info.sampling_ratio * 100.0
        )
    } else {
        String::new()
    }
}

fn build_quality_section(issues: &[QualityIssue]) -> String {
    if issues.is_empty() {
        return r#"<section class="quality">
            <h2>‚ú® Data Quality</h2>
            <div class="no-issues">
                <span class="success-icon">‚úÖ</span>
                <span>No quality issues found!</span>
            </div>
        </section>"#
            .to_string();
    }

    let mut critical_count = 0;
    let mut warning_count = 0;
    let mut info_count = 0;

    let issues_html: String = issues
        .iter()
        .enumerate()
        .map(|(i, issue)| {
            let (icon, severity_class, severity_text) = match issue.severity() {
                Severity::High => {
                    critical_count += 1;
                    ("üî¥", "critical", "CRITICAL")
                }
                Severity::Medium => {
                    warning_count += 1;
                    ("üü°", "warning", "WARNING")
                }
                Severity::Low => {
                    info_count += 1;
                    ("üîµ", "info", "INFO")
                }
            };

            format!(
                r#"<div class="issue {}">
                    <div class="issue-header">
                        <span class="issue-number">{}</span>
                        <span class="issue-icon">{}</span>
                        <span class="severity">{}</span>
                        <span class="issue-description">{}</span>
                    </div>
                    {}
                </div>"#,
                severity_class,
                i + 1,
                icon,
                severity_text,
                format_issue_description(issue),
                format_issue_details(issue)
            )
        })
        .collect();

    let summary = build_quality_summary(critical_count, warning_count, info_count);

    format!(
        r#"<section class="quality">
            <h2>‚ö†Ô∏è Data Quality Issues ({})</h2>
            {}
            <div class="issues-list">
                {}
            </div>
        </section>"#,
        issues.len(),
        summary,
        issues_html
    )
}

fn format_issue_description(issue: &QualityIssue) -> String {
    match issue {
        QualityIssue::NullValues {
            column,
            count,
            percentage,
        } => {
            format!("[{}]: {} null values ({:.1}%)", column, count, percentage)
        }
        QualityIssue::MixedDateFormats { column, .. } => {
            format!("[{}]: Mixed date formats", column)
        }
        QualityIssue::Duplicates { column, count } => {
            format!("[{}]: {} duplicate values", column, count)
        }
        QualityIssue::Outliers {
            column,
            values,
            threshold,
        } => {
            format!(
                "[{}]: {} outliers detected (>{}œÉ)",
                column,
                values.len(),
                threshold
            )
        }
        QualityIssue::MixedTypes { column, .. } => {
            format!("[{}]: Mixed data types", column)
        }
    }
}

fn format_issue_details(issue: &QualityIssue) -> String {
    match issue {
        QualityIssue::MixedDateFormats { formats, .. } => {
            let details: String = formats
                .iter()
                .map(|(format, count)| format!("<li>{}: {} rows</li>", format, count))
                .collect();
            format!("<div class=\"issue-details\"><ul>{}</ul></div>", details)
        }
        QualityIssue::Outliers { values, .. } => {
            let details: String = values
                .iter()
                .take(3)
                .map(|val| format!("<li>{}</li>", val))
                .collect();
            let extra = if values.len() > 3 {
                format!("<li>... and {} more</li>", values.len() - 3)
            } else {
                String::new()
            };
            format!(
                "<div class=\"issue-details\"><ul>{}{}</ul></div>",
                details, extra
            )
        }
        QualityIssue::MixedTypes { types, .. } => {
            let details: String = types
                .iter()
                .map(|(dtype, count)| format!("<li>{}: {} rows</li>", dtype, count))
                .collect();
            format!("<div class=\"issue-details\"><ul>{}</ul></div>", details)
        }
        _ => String::new(),
    }
}

fn build_quality_summary(critical: usize, warning: usize, info: usize) -> String {
    let mut summary_parts = Vec::new();

    if critical > 0 {
        summary_parts.push(format!(
            "<span class=\"critical\">{} critical</span>",
            critical
        ));
    }
    if warning > 0 {
        summary_parts.push(format!(
            "<span class=\"warning\">{} warnings</span>",
            warning
        ));
    }
    if info > 0 {
        summary_parts.push(format!("<span class=\"info\">{} info</span>", info));
    }

    format!(
        r#"<div class="quality-summary">
            üìä Summary: {}
        </div>"#,
        summary_parts.join(" ")
    )
}

fn build_columns_section(columns: &[ColumnProfile]) -> String {
    columns
        .iter()
        .map(|profile| {
            format!(
                r#"<div class="column-card">
                    <h3>{}</h3>
                    <div class="column-meta">
                        <span class="type-badge type-{}">{}</span>
                        <span class="records">{} records</span>
                        {}
                    </div>
                    {}
                    {}
                </div>"#,
                profile.name,
                format_type_class(&profile.data_type),
                format_data_type(&profile.data_type),
                profile.total_count,
                format_null_info(profile.null_count, profile.total_count),
                format_column_stats(&profile.stats),
                format_patterns(&profile.patterns)
            )
        })
        .collect()
}

fn format_data_type(data_type: &DataType) -> String {
    match data_type {
        DataType::String => "String",
        DataType::Integer => "Integer",
        DataType::Float => "Float",
        DataType::Date => "Date",
    }
    .to_string()
}

fn format_type_class(data_type: &DataType) -> String {
    match data_type {
        DataType::String => "string",
        DataType::Integer => "integer",
        DataType::Float => "float",
        DataType::Date => "date",
    }
    .to_string()
}

fn format_null_info(null_count: usize, total_count: usize) -> String {
    if null_count > 0 {
        let pct = (null_count as f64 / total_count as f64) * 100.0;
        format!(
            "<span class=\"nulls warning\">{} nulls ({:.1}%)</span>",
            null_count, pct
        )
    } else {
        "<span class=\"nulls success\">No nulls</span>".to_string()
    }
}

fn format_column_stats(stats: &ColumnStats) -> String {
    match stats {
        ColumnStats::Numeric { min, max, mean } => {
            format!(
                r#"<div class="stats numeric-stats">
                    <div class="stat"><label>Min:</label> <span>{:.2}</span></div>
                    <div class="stat"><label>Max:</label> <span>{:.2}</span></div>
                    <div class="stat"><label>Mean:</label> <span>{:.2}</span></div>
                </div>"#,
                min, max, mean
            )
        }
        ColumnStats::Text {
            min_length,
            max_length,
            avg_length,
        } => {
            format!(
                r#"<div class="stats text-stats">
                    <div class="stat"><label>Min Length:</label> <span>{}</span></div>
                    <div class="stat"><label>Max Length:</label> <span>{}</span></div>
                    <div class="stat"><label>Avg Length:</label> <span>{:.1}</span></div>
                </div>"#,
                min_length, max_length, avg_length
            )
        }
    }
}

fn format_patterns(patterns: &[crate::types::Pattern]) -> String {
    if patterns.is_empty() {
        return String::new();
    }

    let patterns_html: String = patterns
        .iter()
        .map(|pattern| {
            format!(
                "<div class=\"pattern\"><span class=\"pattern-name\">{}</span> - {} matches ({:.1}%)</div>",
                pattern.name, pattern.match_count, pattern.match_percentage
            )
        })
        .collect();

    format!(
        r#"<div class="patterns">
            <h4>Detected Patterns</h4>
            {}
        </div>"#,
        patterns_html
    )
}

fn get_css() -> &'static str {
    r#"
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f7fa;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .file-info h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.3rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 15px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .stat .label {
            font-size: 0.85rem;
            color: #64748b;
            font-weight: 500;
        }

        .stat .value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1e293b;
        }

        .sampling-info {
            margin-top: 15px;
        }

        .sampling-badge {
            background: #fbbf24;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        section h2 {
            font-size: 1.8rem;
            margin-bottom: 25px;
            color: #2d3748;
        }

        .no-issues {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 1.2rem;
            color: #059669;
            font-weight: 500;
        }

        .success-icon {
            font-size: 1.5rem;
        }

        .quality-summary {
            background: #f1f5f9;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            font-weight: 500;
        }

        .quality-summary .critical { color: #dc2626; }
        .quality-summary .warning { color: #d97706; }
        .quality-summary .info { color: #2563eb; }

        .issues-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .issue {
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid;
        }

        .issue.critical {
            background: #fef2f2;
            border-left-color: #dc2626;
        }

        .issue.warning {
            background: #fffbeb;
            border-left-color: #d97706;
        }

        .issue.info {
            background: #eff6ff;
            border-left-color: #2563eb;
        }

        .issue-header {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .issue-number {
            background: #64748b;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .severity {
            font-weight: bold;
            font-size: 0.85rem;
            text-transform: uppercase;
        }

        .issue.critical .severity { color: #dc2626; }
        .issue.warning .severity { color: #d97706; }
        .issue.info .severity { color: #2563eb; }

        .issue-details {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #64748b;
        }

        .issue-details ul {
            list-style: none;
            padding-left: 20px;
        }

        .issue-details li {
            margin-bottom: 5px;
        }

        .columns-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
        }

        .column-card {
            background: #fafafa;
            border-radius: 10px;
            padding: 25px;
            border: 1px solid #e2e8f0;
        }

        .column-card h3 {
            font-size: 1.3rem;
            color: #1e293b;
            margin-bottom: 15px;
        }

        .column-meta {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .type-badge {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .type-string { background: #10b981; color: white; }
        .type-integer { background: #3b82f6; color: white; }
        .type-float { background: #06b6d4; color: white; }
        .type-date { background: #8b5cf6; color: white; }

        .records {
            font-size: 0.9rem;
            color: #64748b;
        }

        .nulls.success { color: #059669; }
        .nulls.warning { color: #d97706; }

        .stats {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            background: none;
            padding: 0;
            border: none;
        }

        .stat label {
            font-weight: 500;
            color: #64748b;
        }

        .stat span {
            font-weight: bold;
            color: #1e293b;
        }

        .patterns {
            background: white;
            padding: 20px;
            border-radius: 8px;
        }

        .patterns h4 {
            margin-bottom: 15px;
            color: #1e293b;
            font-size: 1rem;
        }

        .pattern {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .pattern:last-child {
            border-bottom: none;
        }

        .pattern-name {
            font-weight: 500;
            color: #667eea;
        }

        footer {
            text-align: center;
            padding: 30px;
            color: #64748b;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .container { padding: 10px; }
            header, section { padding: 20px; }
            h1 { font-size: 2rem; }
            .stats-grid { grid-template-columns: 1fr 1fr; }
            .columns-grid { grid-template-columns: 1fr; }
        }
    "#
}

/// Generate an aggregated HTML report for batch processing results
pub fn generate_batch_html_report(batch_result: &BatchResult, output_path: &Path) -> Result<()> {
    let html_content = build_batch_html(batch_result);
    fs::write(output_path, html_content)?;
    Ok(())
}

/// Build the complete HTML content for batch processing dashboard
fn build_batch_html(batch_result: &BatchResult) -> String {
    format!(
        r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataProfiler Batch Analysis Dashboard</title>
    <style>
        {}
        {}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìä DataProfiler Batch Analysis Dashboard</h1>
            {}
        </header>

        {}

        {}

        {}

        <footer>
            <p>Generated by <strong>DataProfiler CLI</strong> v0.4.1 - Batch Processing Mode</p>
        </footer>
    </div>

    <script>
        {}
    </script>
</body>
</html>"#,
        get_css(),
        get_batch_dashboard_css(),
        build_batch_summary_section(&batch_result.summary),
        build_batch_ml_overview(&batch_result.ml_scores),
        build_files_overview(
            &batch_result.reports,
            &batch_result.ml_scores,
            &batch_result.errors
        ),
        build_aggregated_issues(&batch_result.reports),
        get_dashboard_javascript()
    )
}

/// Build the batch processing summary section
fn build_batch_summary_section(summary: &BatchSummary) -> String {
    let success_rate = if summary.total_files > 0 {
        (summary.successful as f64 / summary.total_files as f64) * 100.0
    } else {
        0.0
    };

    let avg_score_color = if summary.average_quality_score >= 80.0 {
        "success"
    } else if summary.average_quality_score >= 60.0 {
        "warning"
    } else {
        "critical"
    };

    format!(
        r#"<div class="batch-summary">
            <div class="summary-grid">
                <div class="summary-card">
                    <div class="card-icon">üìÅ</div>
                    <div class="card-content">
                        <h3>Total Files</h3>
                        <div class="metric">{}</div>
                    </div>
                </div>
                <div class="summary-card success">
                    <div class="card-icon">‚úÖ</div>
                    <div class="card-content">
                        <h3>Success Rate</h3>
                        <div class="metric">{:.1}%</div>
                        <div class="sub-metric">{} successful</div>
                    </div>
                </div>
                <div class="summary-card {}">
                    <div class="card-icon">üìä</div>
                    <div class="card-content">
                        <h3>Avg Quality Score</h3>
                        <div class="metric">{:.1}%</div>
                    </div>
                </div>
                <div class="summary-card">
                    <div class="card-icon">‚ö°</div>
                    <div class="card-content">
                        <h3>Processing Time</h3>
                        <div class="metric">{:.2}s</div>
                        <div class="sub-metric">{:.1} files/sec</div>
                    </div>
                </div>
                <div class="summary-card">
                    <div class="card-icon">üìà</div>
                    <div class="card-content">
                        <h3>Total Records</h3>
                        <div class="metric">{}</div>
                    </div>
                </div>
                <div class="summary-card warning">
                    <div class="card-icon">‚ö†Ô∏è</div>
                    <div class="card-content">
                        <h3>Total Issues</h3>
                        <div class="metric">{}</div>
                    </div>
                </div>
            </div>
        </div>"#,
        summary.total_files,
        success_rate,
        summary.successful,
        avg_score_color,
        summary.average_quality_score,
        summary.processing_time_seconds,
        if summary.processing_time_seconds > 0.0 {
            summary.successful as f64 / summary.processing_time_seconds
        } else {
            0.0
        },
        summary.total_records,
        summary.total_issues
    )
}

/// Build ML readiness overview section
fn build_batch_ml_overview(ml_scores: &HashMap<PathBuf, MlReadinessScore>) -> String {
    if ml_scores.is_empty() {
        return String::new();
    }

    let total_score: f32 = ml_scores
        .values()
        .map(|score| score.overall_score as f32)
        .sum();
    let avg_ml_score = total_score / ml_scores.len() as f32;

    let readiness_counts = ml_scores.values().fold([0; 4], |mut acc, score| {
        match score.overall_score {
            s if s >= 80.0 => acc[0] += 1, // Ready
            s if s >= 60.0 => acc[1] += 1, // Good
            s if s >= 40.0 => acc[2] += 1, // Needs Work
            _ => acc[3] += 1,              // Not Ready
        }
        acc
    });

    format!(
        r#"<section class="ml-overview">
            <h2>ü§ñ ML Readiness Overview</h2>
            <div class="ml-summary-grid">
                <div class="ml-card">
                    <h3>Average ML Score</h3>
                    <div class="ml-score-large">{:.1}%</div>
                    <div class="ml-files-count">{} files analyzed</div>
                </div>
                <div class="ml-distribution">
                    <h3>Readiness Distribution</h3>
                    <div class="readiness-bars">
                        <div class="readiness-bar">
                            <span class="bar-label">Ready (‚â•80%)</span>
                            <div class="bar">
                                <div class="bar-fill ready" style="width: {}%"></div>
                            </div>
                            <span class="bar-count">{}</span>
                        </div>
                        <div class="readiness-bar">
                            <span class="bar-label">Good (60-80%)</span>
                            <div class="bar">
                                <div class="bar-fill good" style="width: {}%"></div>
                            </div>
                            <span class="bar-count">{}</span>
                        </div>
                        <div class="readiness-bar">
                            <span class="bar-label">Needs Work (40-60%)</span>
                            <div class="bar">
                                <div class="bar-fill warning" style="width: {}%"></div>
                            </div>
                            <span class="bar-count">{}</span>
                        </div>
                        <div class="readiness-bar">
                            <span class="bar-label">Not Ready (<40%)</span>
                            <div class="bar">
                                <div class="bar-fill critical" style="width: {}%"></div>
                            </div>
                            <span class="bar-count">{}</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>"#,
        avg_ml_score,
        ml_scores.len(),
        if !ml_scores.is_empty() {
            readiness_counts[0] as f32 / ml_scores.len() as f32 * 100.0
        } else {
            0.0
        },
        readiness_counts[0],
        if !ml_scores.is_empty() {
            readiness_counts[1] as f32 / ml_scores.len() as f32 * 100.0
        } else {
            0.0
        },
        readiness_counts[1],
        if !ml_scores.is_empty() {
            readiness_counts[2] as f32 / ml_scores.len() as f32 * 100.0
        } else {
            0.0
        },
        readiness_counts[2],
        if !ml_scores.is_empty() {
            readiness_counts[3] as f32 / ml_scores.len() as f32 * 100.0
        } else {
            0.0
        },
        readiness_counts[3]
    )
}

/// Build files overview table with quality and ML scores
fn build_files_overview(
    reports: &HashMap<PathBuf, QualityReport>,
    ml_scores: &HashMap<PathBuf, MlReadinessScore>,
    errors: &HashMap<PathBuf, String>,
) -> String {
    let mut files_html = String::new();

    // Collect and sort all files by quality score
    let mut file_data: Vec<_> = reports
        .iter()
        .map(|(path, report)| {
            let quality_score = report.quality_score().unwrap_or(0.0);
            let ml_score = ml_scores.get(path).map(|s| s.overall_score);
            (path, report, quality_score, ml_score)
        })
        .collect();

    file_data.sort_by(|a, b| b.2.partial_cmp(&a.2).unwrap_or(std::cmp::Ordering::Equal));

    for (path, report, quality_score, ml_score_opt) in file_data {
        let filename = path
            .file_name()
            .map_or("unknown", |name| name.to_str().unwrap_or("unknown"));

        let quality_class = if quality_score >= 80.0 {
            "success"
        } else if quality_score >= 60.0 {
            "warning"
        } else {
            "critical"
        };

        let ml_score_display = if let Some(ml_score) = ml_score_opt {
            format!("{:.1}%", ml_score)
        } else {
            "N/A".to_string()
        };

        files_html.push_str(&format!(
            r#"<tr class="file-row" onclick="toggleFileDetails('{}')">
                <td>
                    <div class="file-name">{}</div>
                    <div class="file-path">{}</div>
                </td>
                <td class="score-cell">
                    <span class="score-badge {}">{:.1}%</span>
                </td>
                <td class="score-cell">
                    <span class="ml-score">{}</span>
                </td>
                <td>{}</td>
                <td>{}</td>
                <td>{}</td>
                <td>
                    <button class="details-btn">View Details</button>
                </td>
            </tr>
            <tr class="file-details" id="details-{}" style="display: none;">
                <td colspan="7">
                    <div class="details-content">
                        {}
                    </div>
                </td>
            </tr>"#,
            filename,
            filename,
            path.display(),
            quality_class,
            quality_score,
            ml_score_display,
            report.file_info.total_columns,
            report
                .file_info
                .total_rows
                .map_or("Unknown".to_string(), |r| r.to_string()),
            report.issues.len(),
            filename,
            build_file_details(report, ml_scores.get(path))
        ));
    }

    // Add error files
    for (path, error) in errors {
        let filename = path
            .file_name()
            .map_or("unknown", |name| name.to_str().unwrap_or("unknown"));

        files_html.push_str(&format!(
            r#"<tr class="file-row error">
                <td>
                    <div class="file-name">{}</div>
                    <div class="file-path">{}</div>
                </td>
                <td class="score-cell">
                    <span class="score-badge critical">ERROR</span>
                </td>
                <td>N/A</td>
                <td>N/A</td>
                <td>N/A</td>
                <td>N/A</td>
                <td>
                    <span class="error-message" title="{}">{}</span>
                </td>
            </tr>"#,
            filename,
            path.display(),
            error,
            if error.len() > 50 {
                format!("{}...", &error[..50])
            } else {
                error.clone()
            }
        ));
    }

    format!(
        r#"<section class="files-overview">
            <h2>üìÅ Files Overview</h2>
            <div class="table-container">
                <table class="files-table">
                    <thead>
                        <tr>
                            <th>File</th>
                            <th>Quality Score</th>
                            <th>ML Score</th>
                            <th>Columns</th>
                            <th>Rows</th>
                            <th>Issues</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {}
                    </tbody>
                </table>
            </div>
        </section>"#,
        files_html
    )
}

/// Build detailed view for a specific file
fn build_file_details(report: &QualityReport, ml_score: Option<&MlReadinessScore>) -> String {
    let mut details = String::new();

    // Basic file info
    details.push_str(&format!(
        r#"<div class="file-detail-section">
            <h4>üìä File Information</h4>
            <div class="detail-grid">
                <div><strong>File Size:</strong> {:.1} MB</div>
                <div><strong>Columns:</strong> {}</div>
                <div><strong>Rows:</strong> {}</div>
                <div><strong>Scan Time:</strong> {} ms</div>
            </div>
        </div>"#,
        report.file_info.file_size_mb,
        report.file_info.total_columns,
        report
            .file_info
            .total_rows
            .map_or("Unknown".to_string(), |r| r.to_string()),
        report.scan_info.scan_time_ms
    ));

    // ML Score details if available
    if let Some(ml) = ml_score {
        details.push_str(&format!(
            r#"<div class="file-detail-section">
                <h4>ü§ñ ML Readiness</h4>
                <div class="ml-detail-grid">
                    <div class="ml-score-display">
                        <span class="ml-score-big">{:.1}%</span>
                        <span class="ml-level">{}</span>
                    </div>
                    <div class="ml-recommendations">
                        <h5>Top Recommendations:</h5>
                        <ul>
                            {}
                        </ul>
                    </div>
                </div>
            </div>"#,
            ml.overall_score,
            format_ml_readiness_level(&ml.readiness_level),
            ml.recommendations
                .iter()
                .take(3)
                .map(|rec| format!("<li>{}</li>", rec.description))
                .collect::<Vec<_>>()
                .join("")
        ));
    }

    // Quality issues
    if !report.issues.is_empty() {
        details.push_str(&format!(
            r#"<div class="file-detail-section">
                <h4>‚ö†Ô∏è Quality Issues ({})</h4>
                <div class="issues-list">
                    {}
                </div>
            </div>"#,
            report.issues.len(),
            report
                .issues
                .iter()
                .take(5)
                .map(|issue| format!(
                    r#"<div class="issue-item">{}</div>"#,
                    format_issue_description(issue)
                ))
                .collect::<Vec<_>>()
                .join("")
        ));
    }

    details
}

/// Build aggregated quality issues section
fn build_aggregated_issues(reports: &HashMap<PathBuf, QualityReport>) -> String {
    let mut all_issues = Vec::new();

    for (path, report) in reports {
        for issue in &report.issues {
            all_issues.push((path, issue));
        }
    }

    if all_issues.is_empty() {
        return r#"<section class="aggregated-issues">
                <h2>‚ú® Quality Issues Summary</h2>
                <div class="no-issues">
                    <span class="success-icon">‚úÖ</span>
                    <span>No quality issues found across all files!</span>
                </div>
            </section>"#
            .to_string();
    }

    // Group issues by type and severity
    let mut issue_counts = std::collections::HashMap::new();
    for (_, issue) in &all_issues {
        let issue_type = get_issue_type_name(issue);
        let count = issue_counts.entry(issue_type).or_insert(0);
        *count += 1;
    }

    let mut issue_summary: Vec<_> = issue_counts.into_iter().collect();
    issue_summary.sort_by(|a, b| b.1.cmp(&a.1));

    let issues_html: String = issue_summary
        .iter()
        .take(10)
        .map(|(issue_type, count)| {
            format!(
                r#"<div class="issue-summary-item">
                <div class="issue-type">{}</div>
                <div class="issue-count">{} occurrences</div>
            </div>"#,
                issue_type, count
            )
        })
        .collect();

    format!(
        r#"<section class="aggregated-issues">
            <h2>‚ö†Ô∏è Quality Issues Summary</h2>
            <div class="issues-summary">
                <div class="summary-stats">
                    <div class="stat">
                        <span class="stat-number">{}</span>
                        <span class="stat-label">Total Issues</span>
                    </div>
                    <div class="stat">
                        <span class="stat-number">{}</span>
                        <span class="stat-label">Affected Files</span>
                    </div>
                    <div class="stat">
                        <span class="stat-number">{}</span>
                        <span class="stat-label">Issue Types</span>
                    </div>
                </div>
                <div class="issues-breakdown">
                    <h3>Most Common Issues</h3>
                    {}
                </div>
            </div>
        </section>"#,
        all_issues.len(),
        reports.values().filter(|r| !r.issues.is_empty()).count(),
        issue_summary.len(),
        issues_html
    )
}

fn get_issue_type_name(issue: &QualityIssue) -> String {
    match issue {
        QualityIssue::NullValues { .. } => "Null Values".to_string(),
        QualityIssue::MixedDateFormats { .. } => "Mixed Date Formats".to_string(),
        QualityIssue::Duplicates { .. } => "Duplicate Values".to_string(),
        QualityIssue::Outliers { .. } => "Outliers".to_string(),
        QualityIssue::MixedTypes { .. } => "Mixed Data Types".to_string(),
    }
}

fn format_ml_readiness_level(level: &crate::analysis::MlReadinessLevel) -> String {
    match level {
        crate::analysis::MlReadinessLevel::Ready => "Ready".to_string(),
        crate::analysis::MlReadinessLevel::Good => "Good".to_string(),
        crate::analysis::MlReadinessLevel::NeedsWork => "Needs Work".to_string(),
        crate::analysis::MlReadinessLevel::NotReady => "Not Ready".to_string(),
    }
}

/// Additional CSS for batch dashboard
fn get_batch_dashboard_css() -> &'static str {
    r#"
        .batch-summary {
            margin-bottom: 30px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .summary-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #667eea;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .summary-card.success { border-left-color: #10b981; }
        .summary-card.warning { border-left-color: #f59e0b; }
        .summary-card.critical { border-left-color: #ef4444; }

        .card-icon {
            font-size: 2rem;
        }

        .card-content h3 {
            margin: 0 0 5px 0;
            font-size: 0.9rem;
            color: #64748b;
        }

        .metric {
            font-size: 1.8rem;
            font-weight: bold;
            color: #1e293b;
            margin: 0;
        }

        .sub-metric {
            font-size: 0.8rem;
            color: #64748b;
            margin-top: 2px;
        }

        .ml-overview {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .ml-summary-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-top: 20px;
        }

        .ml-card {
            text-align: center;
            padding: 20px;
            background: #f8fafc;
            border-radius: 10px;
        }

        .ml-score-large {
            font-size: 3rem;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
        }

        .ml-files-count {
            color: #64748b;
            font-size: 0.9rem;
        }

        .readiness-bars {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .readiness-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bar-label {
            min-width: 120px;
            font-size: 0.9rem;
            color: #64748b;
        }

        .bar {
            flex: 1;
            height: 20px;
            background: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .bar-fill.ready { background: #10b981; }
        .bar-fill.good { background: #3b82f6; }
        .bar-fill.warning { background: #f59e0b; }
        .bar-fill.critical { background: #ef4444; }

        .bar-count {
            min-width: 30px;
            text-align: right;
            font-weight: bold;
            color: #1e293b;
        }

        .files-overview {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .table-container {
            overflow-x: auto;
            margin-top: 20px;
        }

        .files-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        .files-table th {
            background: #f8fafc;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            color: #1e293b;
            border-bottom: 2px solid #e2e8f0;
        }

        .files-table td {
            padding: 15px;
            border-bottom: 1px solid #e2e8f0;
            vertical-align: middle;
        }

        .file-row {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .file-row:hover {
            background-color: #f8fafc;
        }

        .file-row.error {
            background-color: #fef2f2;
        }

        .file-name {
            font-weight: 600;
            color: #1e293b;
        }

        .file-path {
            font-size: 0.8rem;
            color: #64748b;
            margin-top: 2px;
        }

        .score-cell {
            text-align: center;
        }

        .score-badge {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .score-badge.success {
            background: #10b981;
            color: white;
        }

        .score-badge.warning {
            background: #f59e0b;
            color: white;
        }

        .score-badge.critical {
            background: #ef4444;
            color: white;
        }

        .ml-score {
            font-weight: 600;
            color: #667eea;
        }

        .details-btn {
            padding: 6px 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .details-btn:hover {
            background: #5a67d8;
        }

        .file-details {
            background: #f8fafc;
        }

        .details-content {
            padding: 20px;
        }

        .file-detail-section {
            margin-bottom: 25px;
        }

        .file-detail-section h4 {
            margin-bottom: 15px;
            color: #1e293b;
            font-size: 1.1rem;
        }

        .detail-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .ml-detail-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }

        .ml-score-display {
            text-align: center;
            padding: 20px;
            background: white;
            border-radius: 8px;
        }

        .ml-score-big {
            display: block;
            font-size: 2.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .ml-level {
            color: #64748b;
            font-size: 0.9rem;
        }

        .ml-recommendations {
            background: white;
            padding: 20px;
            border-radius: 8px;
        }

        .ml-recommendations h5 {
            margin-bottom: 10px;
            color: #1e293b;
        }

        .ml-recommendations ul {
            list-style: none;
            padding: 0;
        }

        .ml-recommendations li {
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
            color: #64748b;
        }

        .issues-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .issue-item {
            padding: 10px;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #f59e0b;
            font-size: 0.9rem;
            color: #64748b;
        }

        .aggregated-issues {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .issues-summary {
            margin-top: 20px;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat {
            text-align: center;
            padding: 20px;
            background: #f8fafc;
            border-radius: 10px;
        }

        .stat-number {
            display: block;
            font-size: 2rem;
            font-weight: bold;
            color: #1e293b;
        }

        .stat-label {
            color: #64748b;
            font-size: 0.9rem;
        }

        .issues-breakdown h3 {
            margin-bottom: 15px;
            color: #1e293b;
        }

        .issue-summary-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .issue-type {
            font-weight: 500;
            color: #1e293b;
        }

        .issue-count {
            color: #64748b;
            font-size: 0.9rem;
        }

        .error-message {
            color: #ef4444;
            font-size: 0.8rem;
        }

        @media (max-width: 768px) {
            .summary-grid {
                grid-template-columns: 1fr;
            }

            .ml-summary-grid {
                grid-template-columns: 1fr;
            }

            .ml-detail-grid {
                grid-template-columns: 1fr;
            }

            .detail-grid {
                grid-template-columns: 1fr;
            }

            .summary-stats {
                grid-template-columns: 1fr;
            }
        }
    "#
}

/// JavaScript for interactive dashboard functionality
fn get_dashboard_javascript() -> &'static str {
    r#"
        function toggleFileDetails(fileId) {
            const detailsRow = document.getElementById('details-' + fileId);
            if (detailsRow) {
                if (detailsRow.style.display === 'none' || detailsRow.style.display === '') {
                    detailsRow.style.display = 'table-row';
                } else {
                    detailsRow.style.display = 'none';
                }
            }
        }

        // Initialize any interactive features when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Add smooth scrolling to any anchor links
            const links = document.querySelectorAll('a[href^="' + '#' + '"]');
            links.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const target = document.querySelector(this.getAttribute('href'));
                    if (target) {
                        target.scrollIntoView({ behavior: 'smooth' });
                    }
                });
            });

            // Add tooltips to score badges
            const scoreBadges = document.querySelectorAll('.score-badge');
            scoreBadges.forEach(badge => {
                const score = parseFloat(badge.textContent);
                let tooltip = '';
                if (score >= 80) {
                    tooltip = 'Excellent data quality';
                } else if (score >= 60) {
                    tooltip = 'Good data quality with some issues';
                } else {
                    tooltip = 'Poor data quality - needs attention';
                }
                badge.setAttribute('title', tooltip);
            });
        });
    "#
}
