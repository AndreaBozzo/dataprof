use crate::analysis::MlReadinessScore;
use crate::core::batch::{BatchResult, BatchSummary};
use crate::types::{
    ColumnProfile, ColumnStats, DataQualityMetrics, DataType, QualityIssue, QualityReport, Severity,
};
use anyhow::Result;
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};

pub fn generate_html_report(report: &QualityReport, output_path: &Path) -> Result<()> {
    let html_content = build_html(report);
    fs::write(output_path, html_content)?;
    Ok(())
}

fn build_html(report: &QualityReport) -> String {
    format!(
        r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataProfiler Report - {}</title>
    <style>
        {}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìä DataProfiler Report</h1>
            <div class="file-info">
                <h2>{}</h2>
                <div class="stats-grid">
                    <div class="stat">
                        <span class="label">File Size</span>
                        <span class="value">{:.1} MB</span>
                    </div>
                    <div class="stat">
                        <span class="label">Total Rows</span>
                        <span class="value">{}</span>
                    </div>
                    <div class="stat">
                        <span class="label">Columns</span>
                        <span class="value">{}</span>
                    </div>
                    <div class="stat">
                        <span class="label">Scan Time</span>
                        <span class="value">{} ms</span>
                    </div>
                </div>
                {}
            </div>
        </header>

        {}

        {}

        <section class="columns">
            <h2>üìà Column Analysis</h2>
            <div class="columns-grid">
                {}
            </div>
        </section>

        <footer>
            <p>Generated by <strong>DataProfiler CLI</strong> v0.2.0</p>
        </footer>
    </div>
</body>
</html>"#,
        Path::new(&report.file_info.path)
            .file_name()
            .unwrap_or_default()
            .to_string_lossy(),
        get_css(),
        report.file_info.path,
        report.file_info.file_size_mb,
        report
            .file_info
            .total_rows
            .map_or("Unknown".to_string(), |r| r.to_string()),
        report.file_info.total_columns,
        report.scan_info.scan_time_ms,
        build_sampling_info(&report.scan_info),
        build_data_quality_metrics_section(&report.data_quality_metrics),
        build_columns_section(&report.column_profiles),
        build_legacy_issues_section(&report.issues, &report.data_quality_metrics)
    )
}

fn build_sampling_info(scan_info: &crate::types::ScanInfo) -> String {
    if scan_info.sampling_ratio < 1.0 {
        format!(
            r#"<div class="sampling-info">
                <span class="sampling-badge">Sampled {} rows ({:.1}%)</span>
            </div>"#,
            scan_info.rows_scanned,
            scan_info.sampling_ratio * 100.0
        )
    } else {
        String::new()
    }
}

fn build_legacy_issues_section(
    issues: &[QualityIssue],
    metrics: &Option<DataQualityMetrics>,
) -> String {
    // If we have comprehensive metrics, skip legacy issues (avoid redundancy)
    if metrics.is_some() {
        return String::new();
    }

    if issues.is_empty() {
        return r#"<section class="quality">
            <h2>‚ú® Data Quality</h2>
            <div class="no-issues">
                <span class="success-icon">‚úÖ</span>
                <span>No quality issues found!</span>
            </div>
        </section>"#
            .to_string();
    }

    let mut critical_count = 0;
    let mut warning_count = 0;
    let mut info_count = 0;

    let issues_html: String = issues
        .iter()
        .enumerate()
        .map(|(i, issue)| {
            let (icon, severity_class, severity_text) = match issue.severity() {
                Severity::High => {
                    critical_count += 1;
                    ("üî¥", "critical", "CRITICAL")
                }
                Severity::Medium => {
                    warning_count += 1;
                    ("üü°", "warning", "WARNING")
                }
                Severity::Low => {
                    info_count += 1;
                    ("üîµ", "info", "INFO")
                }
            };

            format!(
                r#"<div class="issue {}">
                    <div class="issue-header">
                        <span class="issue-number">{}</span>
                        <span class="issue-icon">{}</span>
                        <span class="severity">{}</span>
                        <span class="issue-description">{}</span>
                    </div>
                    {}
                </div>"#,
                severity_class,
                i + 1,
                icon,
                severity_text,
                format_issue_description(issue),
                format_issue_details(issue)
            )
        })
        .collect();

    let summary = build_quality_summary(critical_count, warning_count, info_count);

    format!(
        r#"<section class="quality">
            <h2>‚ö†Ô∏è Data Quality Issues ({})</h2>
            {}
            <div class="issues-list">
                {}
            </div>
        </section>"#,
        issues.len(),
        summary,
        issues_html
    )
}

fn format_issue_description(issue: &QualityIssue) -> String {
    match issue {
        QualityIssue::NullValues {
            column,
            count,
            percentage,
        } => {
            format!("[{}]: {} null values ({:.1}%)", column, count, percentage)
        }
        QualityIssue::MixedDateFormats { column, .. } => {
            format!("[{}]: Mixed date formats", column)
        }
        QualityIssue::Duplicates { column, count } => {
            format!("[{}]: {} duplicate values", column, count)
        }
        QualityIssue::Outliers {
            column,
            values,
            threshold,
        } => {
            format!(
                "[{}]: {} outliers detected (>{}œÉ)",
                column,
                values.len(),
                threshold
            )
        }
        QualityIssue::MixedTypes { column, .. } => {
            format!("[{}]: Mixed data types", column)
        }
    }
}

fn format_issue_details(issue: &QualityIssue) -> String {
    match issue {
        QualityIssue::MixedDateFormats { formats, .. } => {
            let details: String = formats
                .iter()
                .map(|(format, count)| format!("<li>{}: {} rows</li>", format, count))
                .collect();
            format!("<div class=\"issue-details\"><ul>{}</ul></div>", details)
        }
        QualityIssue::Outliers { values, .. } => {
            let details: String = values
                .iter()
                .take(3)
                .map(|val| format!("<li>{}</li>", val))
                .collect();
            let extra = if values.len() > 3 {
                format!("<li>... and {} more</li>", values.len() - 3)
            } else {
                String::new()
            };
            format!(
                "<div class=\"issue-details\"><ul>{}{}</ul></div>",
                details, extra
            )
        }
        QualityIssue::MixedTypes { types, .. } => {
            let details: String = types
                .iter()
                .map(|(dtype, count)| format!("<li>{}: {} rows</li>", dtype, count))
                .collect();
            format!("<div class=\"issue-details\"><ul>{}</ul></div>", details)
        }
        _ => String::new(),
    }
}

fn build_quality_summary(critical: usize, warning: usize, info: usize) -> String {
    let mut summary_parts = Vec::new();

    if critical > 0 {
        summary_parts.push(format!(
            "<span class=\"critical\">{} critical</span>",
            critical
        ));
    }
    if warning > 0 {
        summary_parts.push(format!(
            "<span class=\"warning\">{} warnings</span>",
            warning
        ));
    }
    if info > 0 {
        summary_parts.push(format!("<span class=\"info\">{} info</span>", info));
    }

    format!(
        r#"<div class="quality-summary">
            üìä Summary: {}
        </div>"#,
        summary_parts.join(" ")
    )
}

fn build_data_quality_metrics_section(metrics: &Option<DataQualityMetrics>) -> String {
    match metrics {
        Some(metrics) => {
            // Calculate overall score using the same logic as CLI display
            let overall_score = calculate_overall_data_quality_score(metrics);
            let assessment_class = if overall_score >= 85.0 {
                "excellent"
            } else if overall_score >= 70.0 {
                "good"
            } else if overall_score >= 50.0 {
                "fair"
            } else {
                "poor"
            };

            format!(
                r#"<section class="data-quality-metrics">
                    <h2>üìä Comprehensive Data Quality Metrics</h2>

                    <div class="overall-score">
                        <div class="score-circle {assessment_class}">
                            <span class="score-value">{overall_score:.1}%</span>
                            <span class="score-label">Overall Quality</span>
                        </div>
                    </div>

                    <div class="metrics-grid">
                        <div class="metric-card completeness">
                            <div class="metric-header">
                                <span class="metric-icon">üîç</span>
                                <h3>Completeness</h3>
                            </div>
                            <div class="metric-stats">
                                <div class="stat-item">
                                    <span class="stat-label">Missing Values</span>
                                    <span class="stat-value {missing_class}">{missing_ratio:.1}%</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Complete Records</span>
                                    <span class="stat-value">{complete_ratio:.1}%</span>
                                </div>
                                {null_columns_html}
                            </div>
                        </div>

                        <div class="metric-card consistency">
                            <div class="metric-header">
                                <span class="metric-icon">‚ö°</span>
                                <h3>Consistency</h3>
                            </div>
                            <div class="metric-stats">
                                <div class="stat-item">
                                    <span class="stat-label">Type Consistency</span>
                                    <span class="stat-value {type_class}">{type_consistency:.1}%</span>
                                </div>
                                {format_violations_html}
                                {encoding_issues_html}
                            </div>
                        </div>

                        <div class="metric-card uniqueness">
                            <div class="metric-header">
                                <span class="metric-icon">üîë</span>
                                <h3>Uniqueness</h3>
                            </div>
                            <div class="metric-stats">
                                <div class="stat-item">
                                    <span class="stat-label">Key Uniqueness</span>
                                    <span class="stat-value {uniqueness_class}">{key_uniqueness:.1}%</span>
                                </div>
                                {duplicates_html}
                                {cardinality_html}
                            </div>
                        </div>

                        <div class="metric-card accuracy">
                            <div class="metric-header">
                                <span class="metric-icon">üéØ</span>
                                <h3>Accuracy</h3>
                            </div>
                            <div class="metric-stats">
                                <div class="stat-item">
                                    <span class="stat-label">Outlier Ratio</span>
                                    <span class="stat-value {outlier_class}">{outlier_ratio:.1}%</span>
                                </div>
                                {range_violations_html}
                                {negative_values_html}
                            </div>
                        </div>
                    </div>
                </section>"#,
                assessment_class = assessment_class,
                overall_score = overall_score,
                missing_ratio = metrics.missing_values_ratio,
                missing_class = if metrics.missing_values_ratio <= 5.0 {
                    "excellent"
                } else if metrics.missing_values_ratio <= 15.0 {
                    "good"
                } else {
                    "poor"
                },
                complete_ratio = metrics.complete_records_ratio,
                null_columns_html = if !metrics.null_columns.is_empty() {
                    format!(
                        r#"<div class="stat-item warning">
                        <span class="stat-label">Columns with nulls</span>
                        <span class="stat-value">{}</span>
                    </div>"#,
                        metrics.null_columns.join(", ")
                    )
                } else {
                    String::new()
                },
                type_consistency = metrics.data_type_consistency,
                type_class = if metrics.data_type_consistency >= 95.0 {
                    "excellent"
                } else if metrics.data_type_consistency >= 80.0 {
                    "good"
                } else {
                    "poor"
                },
                format_violations_html = if metrics.format_violations > 0 {
                    format!(
                        r#"<div class="stat-item warning">
                        <span class="stat-label">Format Violations</span>
                        <span class="stat-value">{}</span>
                    </div>"#,
                        metrics.format_violations
                    )
                } else {
                    String::new()
                },
                encoding_issues_html = if metrics.encoding_issues > 0 {
                    format!(
                        r#"<div class="stat-item error">
                        <span class="stat-label">Encoding Issues</span>
                        <span class="stat-value">{}</span>
                    </div>"#,
                        metrics.encoding_issues
                    )
                } else {
                    String::new()
                },
                key_uniqueness = metrics.key_uniqueness,
                uniqueness_class = if metrics.key_uniqueness >= 95.0 {
                    "excellent"
                } else if metrics.key_uniqueness >= 80.0 {
                    "good"
                } else {
                    "poor"
                },
                duplicates_html = if metrics.duplicate_rows > 0 {
                    format!(
                        r#"<div class="stat-item warning">
                        <span class="stat-label">Duplicate Rows</span>
                        <span class="stat-value">{}</span>
                    </div>"#,
                        metrics.duplicate_rows
                    )
                } else {
                    r#"<div class="stat-item excellent">
                        <span class="stat-label">Duplicate Rows</span>
                        <span class="stat-value">None</span>
                    </div>"#
                        .to_string()
                },
                cardinality_html = if metrics.high_cardinality_warning {
                    r#"<div class="stat-item warning">
                        <span class="stat-label">High Cardinality</span>
                        <span class="stat-value">Warning</span>
                    </div>"#
                        .to_string()
                } else {
                    String::new()
                },
                outlier_ratio = metrics.outlier_ratio,
                outlier_class = if metrics.outlier_ratio <= 2.0 {
                    "excellent"
                } else if metrics.outlier_ratio <= 5.0 {
                    "good"
                } else {
                    "poor"
                },
                range_violations_html = if metrics.range_violations > 0 {
                    format!(
                        r#"<div class="stat-item warning">
                        <span class="stat-label">Range Violations</span>
                        <span class="stat-value">{}</span>
                    </div>"#,
                        metrics.range_violations
                    )
                } else {
                    String::new()
                },
                negative_values_html = if metrics.negative_values_in_positive > 0 {
                    format!(
                        r#"<div class="stat-item error">
                        <span class="stat-label">Invalid Negatives</span>
                        <span class="stat-value">{}</span>
                    </div>"#,
                        metrics.negative_values_in_positive
                    )
                } else {
                    String::new()
                }
            )
        }
        None => String::new(), // No metrics available
    }
}

/// Calculate overall data quality score (same logic as CLI display)
fn calculate_overall_data_quality_score(metrics: &DataQualityMetrics) -> f64 {
    let completeness_weight = 0.3;
    let consistency_weight = 0.3;
    let uniqueness_weight = 0.2;
    let accuracy_weight = 0.2;

    let completeness_score = 100.0 - metrics.missing_values_ratio;
    let consistency_score = metrics.data_type_consistency;
    let uniqueness_score = metrics.key_uniqueness;
    let accuracy_score = 100.0 - (metrics.outlier_ratio * 10.0);

    let overall = (completeness_score * completeness_weight)
        + (consistency_score * consistency_weight)
        + (uniqueness_score * uniqueness_weight)
        + (accuracy_score.clamp(0.0, 100.0) * accuracy_weight);

    overall.clamp(0.0, 100.0)
}

fn build_columns_section(columns: &[ColumnProfile]) -> String {
    columns
        .iter()
        .map(|profile| {
            format!(
                r#"<div class="column-card">
                    <h3>{}</h3>
                    <div class="column-meta">
                        <span class="type-badge type-{}">{}</span>
                        <span class="records">{} records</span>
                        {}
                    </div>
                    {}
                    {}
                </div>"#,
                profile.name,
                format_type_class(&profile.data_type),
                format_data_type(&profile.data_type),
                profile.total_count,
                format_null_info(profile.null_count, profile.total_count),
                format_column_stats(&profile.stats),
                format_patterns(&profile.patterns)
            )
        })
        .collect()
}

fn format_data_type(data_type: &DataType) -> String {
    match data_type {
        DataType::String => "String",
        DataType::Integer => "Integer",
        DataType::Float => "Float",
        DataType::Date => "Date",
    }
    .to_string()
}

fn format_type_class(data_type: &DataType) -> String {
    match data_type {
        DataType::String => "string",
        DataType::Integer => "integer",
        DataType::Float => "float",
        DataType::Date => "date",
    }
    .to_string()
}

fn format_null_info(null_count: usize, total_count: usize) -> String {
    if null_count > 0 {
        let pct = (null_count as f64 / total_count as f64) * 100.0;
        format!(
            "<span class=\"nulls warning\">{} nulls ({:.1}%)</span>",
            null_count, pct
        )
    } else {
        "<span class=\"nulls success\">No nulls</span>".to_string()
    }
}

fn format_column_stats(stats: &ColumnStats) -> String {
    match stats {
        ColumnStats::Numeric { min, max, mean } => {
            format!(
                r#"<div class="stats numeric-stats">
                    <div class="stat"><label>Min:</label> <span>{:.2}</span></div>
                    <div class="stat"><label>Max:</label> <span>{:.2}</span></div>
                    <div class="stat"><label>Mean:</label> <span>{:.2}</span></div>
                </div>"#,
                min, max, mean
            )
        }
        ColumnStats::Text {
            min_length,
            max_length,
            avg_length,
        } => {
            format!(
                r#"<div class="stats text-stats">
                    <div class="stat"><label>Min Length:</label> <span>{}</span></div>
                    <div class="stat"><label>Max Length:</label> <span>{}</span></div>
                    <div class="stat"><label>Avg Length:</label> <span>{:.1}</span></div>
                </div>"#,
                min_length, max_length, avg_length
            )
        }
    }
}

fn format_patterns(patterns: &[crate::types::Pattern]) -> String {
    if patterns.is_empty() {
        return String::new();
    }

    let patterns_html: String = patterns
        .iter()
        .map(|pattern| {
            format!(
                "<div class=\"pattern\"><span class=\"pattern-name\">{}</span> - {} matches ({:.1}%)</div>",
                pattern.name, pattern.match_count, pattern.match_percentage
            )
        })
        .collect();

    format!(
        r#"<div class="patterns">
            <h4>Detected Patterns</h4>
            {}
        </div>"#,
        patterns_html
    )
}

fn get_css() -> &'static str {
    r#"
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f7fa;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .file-info h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.3rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 15px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .stat .label {
            font-size: 0.85rem;
            color: #64748b;
            font-weight: 500;
        }

        .stat .value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1e293b;
        }

        .sampling-info {
            margin-top: 15px;
        }

        .sampling-badge {
            background: #fbbf24;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        section h2 {
            font-size: 1.8rem;
            margin-bottom: 25px;
            color: #2d3748;
        }

        .no-issues {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 1.2rem;
            color: #059669;
            font-weight: 500;
        }

        .success-icon {
            font-size: 1.5rem;
        }

        .quality-summary {
            background: #f1f5f9;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            font-weight: 500;
        }

        .quality-summary .critical { color: #dc2626; }
        .quality-summary .warning { color: #d97706; }
        .quality-summary .info { color: #2563eb; }

        .issues-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .issue {
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid;
        }

        .issue.critical {
            background: #fef2f2;
            border-left-color: #dc2626;
        }

        .issue.warning {
            background: #fffbeb;
            border-left-color: #d97706;
        }

        .issue.info {
            background: #eff6ff;
            border-left-color: #2563eb;
        }

        .issue-header {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .issue-number {
            background: #64748b;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .severity {
            font-weight: bold;
            font-size: 0.85rem;
            text-transform: uppercase;
        }

        .issue.critical .severity { color: #dc2626; }
        .issue.warning .severity { color: #d97706; }
        .issue.info .severity { color: #2563eb; }

        .issue-details {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #64748b;
        }

        .issue-details ul {
            list-style: none;
            padding-left: 20px;
        }

        .issue-details li {
            margin-bottom: 5px;
        }

        .columns-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
        }

        .column-card {
            background: #fafafa;
            border-radius: 10px;
            padding: 25px;
            border: 1px solid #e2e8f0;
        }

        .column-card h3 {
            font-size: 1.3rem;
            color: #1e293b;
            margin-bottom: 15px;
        }

        .column-meta {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .type-badge {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .type-string { background: #10b981; color: white; }
        .type-integer { background: #3b82f6; color: white; }
        .type-float { background: #06b6d4; color: white; }
        .type-date { background: #8b5cf6; color: white; }

        .records {
            font-size: 0.9rem;
            color: #64748b;
        }

        .nulls.success { color: #059669; }
        .nulls.warning { color: #d97706; }

        .stats {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            background: none;
            padding: 0;
            border: none;
        }

        .stat label {
            font-weight: 500;
            color: #64748b;
        }

        .stat span {
            font-weight: bold;
            color: #1e293b;
        }

        .patterns {
            background: white;
            padding: 20px;
            border-radius: 8px;
        }

        .patterns h4 {
            margin-bottom: 15px;
            color: #1e293b;
            font-size: 1rem;
        }

        .pattern {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .pattern:last-child {
            border-bottom: none;
        }

        .pattern-name {
            font-weight: 500;
            color: #667eea;
        }

        footer {
            text-align: center;
            padding: 30px;
            color: #64748b;
            font-size: 0.9rem;
        }

        /* Data Quality Metrics Styles */
        .data-quality-metrics {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .overall-score {
            text-align: center;
            margin-bottom: 40px;
        }

        .score-circle {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 6px solid;
            background: white;
            margin: 0 auto;
        }

        .score-circle.excellent {
            border-color: #10b981;
            color: #10b981;
        }

        .score-circle.good {
            border-color: #3b82f6;
            color: #3b82f6;
        }

        .score-circle.fair {
            border-color: #f59e0b;
            color: #f59e0b;
        }

        .score-circle.poor {
            border-color: #ef4444;
            color: #ef4444;
        }

        .score-value {
            font-size: 24px;
            font-weight: bold;
            line-height: 1;
        }

        .score-label {
            font-size: 12px;
            margin-top: 4px;
            opacity: 0.8;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .metric-card {
            background: #f8fafc;
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid;
        }

        .metric-card.completeness {
            border-left-color: #10b981;
        }

        .metric-card.consistency {
            border-left-color: #3b82f6;
        }

        .metric-card.uniqueness {
            border-left-color: #8b5cf6;
        }

        .metric-card.accuracy {
            border-left-color: #ef4444;
        }

        .metric-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .metric-icon {
            font-size: 20px;
            margin-right: 8px;
        }

        .metric-header h3 {
            margin: 0;
            font-size: 16px;
            color: #374151;
        }

        .metric-stats {
            space-y: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 14px;
            color: #6b7280;
        }

        .stat-value {
            font-weight: 600;
            font-size: 14px;
        }

        .stat-value.excellent {
            color: #10b981;
        }

        .stat-value.good {
            color: #3b82f6;
        }

        .stat-value.warning {
            color: #f59e0b;
        }

        .stat-value.error,
        .stat-value.poor {
            color: #ef4444;
        }

        @media (max-width: 768px) {
            .container { padding: 10px; }
            header, section { padding: 20px; }
            h1 { font-size: 2rem; }
            .stats-grid { grid-template-columns: 1fr 1fr; }
            .columns-grid { grid-template-columns: 1fr; }
            .metrics-grid { grid-template-columns: 1fr; }
            .score-circle { width: 100px; height: 100px; }
            .score-value { font-size: 20px; }
        }
    "#
}

/// Generate an aggregated HTML report for batch processing results
pub fn generate_batch_html_report(batch_result: &BatchResult, output_path: &Path) -> Result<()> {
    let html_content = build_batch_html(batch_result);
    fs::write(output_path, html_content)?;
    Ok(())
}

/// Build the complete HTML content for batch processing dashboard
fn build_batch_html(batch_result: &BatchResult) -> String {
    format!(
        r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataProfiler Batch Analysis Dashboard</title>
    <style>
        {}
        {}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìä DataProfiler Batch Analysis Dashboard</h1>
            {}
        </header>

        {}

        {}

        {}

        {}

        <footer>
            <p>Generated by <strong>DataProfiler CLI</strong> v0.4.1 - Batch Processing Mode</p>
        </footer>
    </div>

    <script>
        {}
    </script>
</body>
</html>"#,
        get_css(),
        get_batch_dashboard_css(),
        build_batch_summary_section(&batch_result.summary),
        build_batch_aggregated_data_quality_section(
            &batch_result.summary.aggregated_data_quality_metrics
        ),
        build_batch_ml_overview(&batch_result.ml_scores),
        build_files_overview(
            &batch_result.reports,
            &batch_result.ml_scores,
            &batch_result.errors
        ),
        build_aggregated_issues(&batch_result.reports),
        get_dashboard_javascript()
    )
}

/// Build the batch processing summary section
fn build_batch_summary_section(summary: &BatchSummary) -> String {
    let success_rate = if summary.total_files > 0 {
        (summary.successful as f64 / summary.total_files as f64) * 100.0
    } else {
        0.0
    };

    let avg_score_color = if summary.average_quality_score >= 80.0 {
        "success"
    } else if summary.average_quality_score >= 60.0 {
        "warning"
    } else {
        "critical"
    };

    format!(
        r#"<div class="batch-summary">
            <div class="summary-grid">
                <div class="summary-card">
                    <div class="card-icon">üìÅ</div>
                    <div class="card-content">
                        <h3>Total Files</h3>
                        <div class="metric">{}</div>
                    </div>
                </div>
                <div class="summary-card success">
                    <div class="card-icon">‚úÖ</div>
                    <div class="card-content">
                        <h3>Success Rate</h3>
                        <div class="metric">{:.1}%</div>
                        <div class="sub-metric">{} successful</div>
                    </div>
                </div>
                <div class="summary-card {}">
                    <div class="card-icon">üìä</div>
                    <div class="card-content">
                        <h3>Avg Quality Score</h3>
                        <div class="metric">{:.1}%</div>
                    </div>
                </div>
                <div class="summary-card">
                    <div class="card-icon">‚ö°</div>
                    <div class="card-content">
                        <h3>Processing Time</h3>
                        <div class="metric">{:.2}s</div>
                        <div class="sub-metric">{:.1} files/sec</div>
                    </div>
                </div>
                <div class="summary-card">
                    <div class="card-icon">üìà</div>
                    <div class="card-content">
                        <h3>Total Records</h3>
                        <div class="metric">{}</div>
                    </div>
                </div>
                <div class="summary-card warning">
                    <div class="card-icon">‚ö†Ô∏è</div>
                    <div class="card-content">
                        <h3>Total Issues</h3>
                        <div class="metric">{}</div>
                    </div>
                </div>
            </div>
        </div>"#,
        summary.total_files,
        success_rate,
        summary.successful,
        avg_score_color,
        summary.average_quality_score,
        summary.processing_time_seconds,
        if summary.processing_time_seconds > 0.0 {
            summary.successful as f64 / summary.processing_time_seconds
        } else {
            0.0
        },
        summary.total_records,
        summary.total_issues
    )
}

/// Build aggregated data quality metrics section for batch dashboard
fn build_batch_aggregated_data_quality_section(
    aggregated_metrics: &Option<crate::types::DataQualityMetrics>,
) -> String {
    match aggregated_metrics {
        Some(metrics) => {
            // Calculate overall score using the same logic as single file reports
            let overall_score = calculate_overall_data_quality_score(metrics);
            let assessment_class = if overall_score >= 85.0 {
                "excellent"
            } else if overall_score >= 70.0 {
                "good"
            } else if overall_score >= 50.0 {
                "fair"
            } else {
                "poor"
            };

            format!(
                r#"<section class="batch-aggregated-quality-metrics">
                    <h2>üèÜ Aggregated Data Quality Metrics</h2>
                    <div class="aggregated-intro">
                        <p>Cross-file aggregated metrics representing the overall data quality across all processed files</p>
                    </div>

                    <div class="overall-score">
                        <div class="score-circle {assessment_class}">
                            <span class="score-value">{overall_score:.1}%</span>
                            <span class="score-label">Overall Dataset Quality</span>
                        </div>
                    </div>

                    <div class="metrics-grid">
                        <div class="metric-card completeness">
                            <div class="metric-header">
                                <span class="metric-icon">üîç</span>
                                <h3>Completeness</h3>
                            </div>
                            <div class="metric-stats">
                                <div class="stat-item">
                                    <span class="stat-label">Missing Values</span>
                                    <span class="stat-value {missing_class}">{missing_ratio:.1}%</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Complete Records</span>
                                    <span class="stat-value">{complete_ratio:.1}%</span>
                                </div>
                                {null_columns_html}
                            </div>
                        </div>

                        <div class="metric-card consistency">
                            <div class="metric-header">
                                <span class="metric-icon">‚ö°</span>
                                <h3>Consistency</h3>
                            </div>
                            <div class="metric-stats">
                                <div class="stat-item">
                                    <span class="stat-label">Type Consistency</span>
                                    <span class="stat-value {type_class}">{type_consistency:.1}%</span>
                                </div>
                                {format_violations_html}
                                {encoding_issues_html}
                            </div>
                        </div>

                        <div class="metric-card uniqueness">
                            <div class="metric-header">
                                <span class="metric-icon">üîë</span>
                                <h3>Uniqueness</h3>
                            </div>
                            <div class="metric-stats">
                                <div class="stat-item">
                                    <span class="stat-label">Key Uniqueness</span>
                                    <span class="stat-value {uniqueness_class}">{key_uniqueness:.1}%</span>
                                </div>
                                {duplicates_html}
                                {cardinality_html}
                            </div>
                        </div>

                        <div class="metric-card accuracy">
                            <div class="metric-header">
                                <span class="metric-icon">üéØ</span>
                                <h3>Accuracy</h3>
                            </div>
                            <div class="metric-stats">
                                <div class="stat-item">
                                    <span class="stat-label">Outlier Ratio</span>
                                    <span class="stat-value {outlier_class}">{outlier_ratio:.1}%</span>
                                </div>
                                {range_violations_html}
                                {negative_values_html}
                            </div>
                        </div>
                    </div>
                </section>"#,
                assessment_class = assessment_class,
                overall_score = overall_score,
                missing_ratio = metrics.missing_values_ratio,
                missing_class = if metrics.missing_values_ratio <= 5.0 {
                    "excellent"
                } else if metrics.missing_values_ratio <= 15.0 {
                    "good"
                } else {
                    "poor"
                },
                complete_ratio = metrics.complete_records_ratio,
                null_columns_html = if !metrics.null_columns.is_empty() {
                    format!(
                        r#"<div class="stat-item warning">
                        <span class="stat-label">Columns with nulls</span>
                        <span class="stat-value">{}</span>
                    </div>"#,
                        if metrics.null_columns.len() > 5 {
                            format!(
                                "{} columns ({}...)",
                                metrics.null_columns.len(),
                                metrics.null_columns[..3].join(", ")
                            )
                        } else {
                            metrics.null_columns.join(", ")
                        }
                    )
                } else {
                    String::new()
                },
                type_consistency = metrics.data_type_consistency,
                type_class = if metrics.data_type_consistency >= 95.0 {
                    "excellent"
                } else if metrics.data_type_consistency >= 80.0 {
                    "good"
                } else {
                    "poor"
                },
                format_violations_html = if metrics.format_violations > 0 {
                    format!(
                        r#"<div class="stat-item warning">
                        <span class="stat-label">Format Violations</span>
                        <span class="stat-value">{} total</span>
                    </div>"#,
                        metrics.format_violations
                    )
                } else {
                    String::new()
                },
                encoding_issues_html = if metrics.encoding_issues > 0 {
                    format!(
                        r#"<div class="stat-item error">
                        <span class="stat-label">Encoding Issues</span>
                        <span class="stat-value">{} total</span>
                    </div>"#,
                        metrics.encoding_issues
                    )
                } else {
                    String::new()
                },
                key_uniqueness = metrics.key_uniqueness,
                uniqueness_class = if metrics.key_uniqueness >= 95.0 {
                    "excellent"
                } else if metrics.key_uniqueness >= 80.0 {
                    "good"
                } else {
                    "poor"
                },
                duplicates_html = if metrics.duplicate_rows > 0 {
                    format!(
                        r#"<div class="stat-item warning">
                        <span class="stat-label">Duplicate Rows</span>
                        <span class="stat-value">{} total</span>
                    </div>"#,
                        metrics.duplicate_rows
                    )
                } else {
                    r#"<div class="stat-item excellent">
                        <span class="stat-label">Duplicate Rows</span>
                        <span class="stat-value">None</span>
                    </div>"#
                        .to_string()
                },
                cardinality_html = if metrics.high_cardinality_warning {
                    r#"<div class="stat-item warning">
                        <span class="stat-label">High Cardinality</span>
                        <span class="stat-value">Warning</span>
                    </div>"#
                        .to_string()
                } else {
                    String::new()
                },
                outlier_ratio = metrics.outlier_ratio,
                outlier_class = if metrics.outlier_ratio <= 2.0 {
                    "excellent"
                } else if metrics.outlier_ratio <= 5.0 {
                    "good"
                } else {
                    "poor"
                },
                range_violations_html = if metrics.range_violations > 0 {
                    format!(
                        r#"<div class="stat-item warning">
                        <span class="stat-label">Range Violations</span>
                        <span class="stat-value">{} total</span>
                    </div>"#,
                        metrics.range_violations
                    )
                } else {
                    String::new()
                },
                negative_values_html = if metrics.negative_values_in_positive > 0 {
                    format!(
                        r#"<div class="stat-item error">
                        <span class="stat-label">Invalid Negatives</span>
                        <span class="stat-value">{} total</span>
                    </div>"#,
                        metrics.negative_values_in_positive
                    )
                } else {
                    String::new()
                }
            )
        }
        None => String::new(), // No aggregated metrics available
    }
}

/// Build ML readiness overview section
fn build_batch_ml_overview(ml_scores: &HashMap<PathBuf, MlReadinessScore>) -> String {
    if ml_scores.is_empty() {
        return String::new();
    }

    let total_score: f32 = ml_scores
        .values()
        .map(|score| score.overall_score as f32)
        .sum();
    let avg_ml_score = total_score / ml_scores.len() as f32;

    let readiness_counts = ml_scores.values().fold([0; 4], |mut acc, score| {
        match score.overall_score {
            s if s >= 80.0 => acc[0] += 1, // Ready
            s if s >= 60.0 => acc[1] += 1, // Good
            s if s >= 40.0 => acc[2] += 1, // Needs Work
            _ => acc[3] += 1,              // Not Ready
        }
        acc
    });

    format!(
        r#"<section class="ml-overview">
            <h2>ü§ñ ML Readiness Overview</h2>
            <div class="ml-summary-grid">
                <div class="ml-card">
                    <h3>Average ML Score</h3>
                    <div class="ml-score-large">{:.1}%</div>
                    <div class="ml-files-count">{} files analyzed</div>
                </div>
                <div class="ml-distribution">
                    <h3>Readiness Distribution</h3>
                    <div class="readiness-bars">
                        <div class="readiness-bar">
                            <span class="bar-label">Ready (‚â•80%)</span>
                            <div class="bar">
                                <div class="bar-fill ready" style="width: {}%"></div>
                            </div>
                            <span class="bar-count">{}</span>
                        </div>
                        <div class="readiness-bar">
                            <span class="bar-label">Good (60-80%)</span>
                            <div class="bar">
                                <div class="bar-fill good" style="width: {}%"></div>
                            </div>
                            <span class="bar-count">{}</span>
                        </div>
                        <div class="readiness-bar">
                            <span class="bar-label">Needs Work (40-60%)</span>
                            <div class="bar">
                                <div class="bar-fill warning" style="width: {}%"></div>
                            </div>
                            <span class="bar-count">{}</span>
                        </div>
                        <div class="readiness-bar">
                            <span class="bar-label">Not Ready (<40%)</span>
                            <div class="bar">
                                <div class="bar-fill critical" style="width: {}%"></div>
                            </div>
                            <span class="bar-count">{}</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>"#,
        avg_ml_score,
        ml_scores.len(),
        if !ml_scores.is_empty() {
            readiness_counts[0] as f32 / ml_scores.len() as f32 * 100.0
        } else {
            0.0
        },
        readiness_counts[0],
        if !ml_scores.is_empty() {
            readiness_counts[1] as f32 / ml_scores.len() as f32 * 100.0
        } else {
            0.0
        },
        readiness_counts[1],
        if !ml_scores.is_empty() {
            readiness_counts[2] as f32 / ml_scores.len() as f32 * 100.0
        } else {
            0.0
        },
        readiness_counts[2],
        if !ml_scores.is_empty() {
            readiness_counts[3] as f32 / ml_scores.len() as f32 * 100.0
        } else {
            0.0
        },
        readiness_counts[3]
    )
}

/// Build files overview table with quality and ML scores
fn build_files_overview(
    reports: &HashMap<PathBuf, QualityReport>,
    ml_scores: &HashMap<PathBuf, MlReadinessScore>,
    errors: &HashMap<PathBuf, String>,
) -> String {
    let mut files_html = String::new();

    // Collect and sort all files by quality score
    let mut file_data: Vec<_> = reports
        .iter()
        .map(|(path, report)| {
            let quality_score = report.quality_score().unwrap_or(0.0);
            let ml_score = ml_scores.get(path).map(|s| s.overall_score);
            (path, report, quality_score, ml_score)
        })
        .collect();

    file_data.sort_by(|a, b| b.2.partial_cmp(&a.2).unwrap_or(std::cmp::Ordering::Equal));

    for (path, report, quality_score, ml_score_opt) in file_data {
        let filename = path
            .file_name()
            .map_or("unknown", |name| name.to_str().unwrap_or("unknown"));

        let quality_class = if quality_score >= 80.0 {
            "success"
        } else if quality_score >= 60.0 {
            "warning"
        } else {
            "critical"
        };

        let ml_score_display = if let Some(ml_score) = ml_score_opt {
            format!("{:.1}%", ml_score)
        } else {
            "N/A".to_string()
        };

        files_html.push_str(&format!(
            r#"<tr class="file-row" onclick="toggleFileDetails('{}')">
                <td>
                    <div class="file-name">{}</div>
                    <div class="file-path">{}</div>
                </td>
                <td class="score-cell">
                    <span class="score-badge {}">{:.1}%</span>
                </td>
                <td class="score-cell">
                    <span class="ml-score">{}</span>
                </td>
                <td>{}</td>
                <td>{}</td>
                <td>{}</td>
                <td>
                    <button class="details-btn">View Details</button>
                </td>
            </tr>
            <tr class="file-details" id="details-{}" style="display: none;">
                <td colspan="7">
                    <div class="details-content">
                        {}
                    </div>
                </td>
            </tr>"#,
            filename,
            filename,
            path.display(),
            quality_class,
            quality_score,
            ml_score_display,
            report.file_info.total_columns,
            report
                .file_info
                .total_rows
                .map_or("Unknown".to_string(), |r| r.to_string()),
            report.issues.len(),
            filename,
            build_file_details(report, ml_scores.get(path))
        ));
    }

    // Add error files
    for (path, error) in errors {
        let filename = path
            .file_name()
            .map_or("unknown", |name| name.to_str().unwrap_or("unknown"));

        files_html.push_str(&format!(
            r#"<tr class="file-row error">
                <td>
                    <div class="file-name">{}</div>
                    <div class="file-path">{}</div>
                </td>
                <td class="score-cell">
                    <span class="score-badge critical">ERROR</span>
                </td>
                <td>N/A</td>
                <td>N/A</td>
                <td>N/A</td>
                <td>N/A</td>
                <td>
                    <span class="error-message" title="{}">{}</span>
                </td>
            </tr>"#,
            filename,
            path.display(),
            error,
            if error.len() > 50 {
                format!("{}...", &error[..50])
            } else {
                error.clone()
            }
        ));
    }

    format!(
        r#"<section class="files-overview">
            <h2>üìÅ Files Overview</h2>
            <div class="table-container">
                <table class="files-table">
                    <thead>
                        <tr>
                            <th>File</th>
                            <th>Quality Score</th>
                            <th>ML Score</th>
                            <th>Columns</th>
                            <th>Rows</th>
                            <th>Issues</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {}
                    </tbody>
                </table>
            </div>
        </section>"#,
        files_html
    )
}

/// Build detailed view for a specific file
fn build_file_details(report: &QualityReport, ml_score: Option<&MlReadinessScore>) -> String {
    let mut details = String::new();

    // Basic file info
    details.push_str(&format!(
        r#"<div class="file-detail-section">
            <h4>üìä File Information</h4>
            <div class="detail-grid">
                <div><strong>File Size:</strong> {:.1} MB</div>
                <div><strong>Columns:</strong> {}</div>
                <div><strong>Rows:</strong> {}</div>
                <div><strong>Scan Time:</strong> {} ms</div>
            </div>
        </div>"#,
        report.file_info.file_size_mb,
        report.file_info.total_columns,
        report
            .file_info
            .total_rows
            .map_or("Unknown".to_string(), |r| r.to_string()),
        report.scan_info.scan_time_ms
    ));

    // ML Score details if available
    if let Some(ml) = ml_score {
        details.push_str(&format!(
            r#"<div class="file-detail-section">
                <h4>ü§ñ ML Readiness</h4>
                <div class="ml-detail-grid">
                    <div class="ml-score-display">
                        <span class="ml-score-big">{:.1}%</span>
                        <span class="ml-level">{}</span>
                    </div>
                    <div class="ml-recommendations">
                        <h5>Top Recommendations:</h5>
                        <ul>
                            {}
                        </ul>
                    </div>
                </div>
            </div>"#,
            ml.overall_score,
            format_ml_readiness_level(&ml.readiness_level),
            ml.recommendations
                .iter()
                .take(3)
                .map(|rec| format!("<li>{}</li>", rec.description))
                .collect::<Vec<_>>()
                .join("")
        ));
    }

    // Quality issues
    if !report.issues.is_empty() {
        details.push_str(&format!(
            r#"<div class="file-detail-section">
                <h4>‚ö†Ô∏è Quality Issues ({})</h4>
                <div class="issues-list">
                    {}
                </div>
            </div>"#,
            report.issues.len(),
            report
                .issues
                .iter()
                .take(5)
                .map(|issue| format!(
                    r#"<div class="issue-item">{}</div>"#,
                    format_issue_description(issue)
                ))
                .collect::<Vec<_>>()
                .join("")
        ));
    }

    details
}

/// Build aggregated quality issues section
fn build_aggregated_issues(reports: &HashMap<PathBuf, QualityReport>) -> String {
    let mut all_issues = Vec::new();

    for (path, report) in reports {
        for issue in &report.issues {
            all_issues.push((path, issue));
        }
    }

    if all_issues.is_empty() {
        return r#"<section class="aggregated-issues">
                <h2>‚ú® Quality Issues Summary</h2>
                <div class="no-issues">
                    <span class="success-icon">‚úÖ</span>
                    <span>No quality issues found across all files!</span>
                </div>
            </section>"#
            .to_string();
    }

    // Group issues by type and severity
    let mut issue_counts = std::collections::HashMap::new();
    for (_, issue) in &all_issues {
        let issue_type = get_issue_type_name(issue);
        let count = issue_counts.entry(issue_type).or_insert(0);
        *count += 1;
    }

    let mut issue_summary: Vec<_> = issue_counts.into_iter().collect();
    issue_summary.sort_by(|a, b| b.1.cmp(&a.1));

    let issues_html: String = issue_summary
        .iter()
        .take(10)
        .map(|(issue_type, count)| {
            format!(
                r#"<div class="issue-summary-item">
                <div class="issue-type">{}</div>
                <div class="issue-count">{} occurrences</div>
            </div>"#,
                issue_type, count
            )
        })
        .collect();

    format!(
        r#"<section class="aggregated-issues">
            <h2>‚ö†Ô∏è Quality Issues Summary</h2>
            <div class="issues-summary">
                <div class="summary-stats">
                    <div class="stat">
                        <span class="stat-number">{}</span>
                        <span class="stat-label">Total Issues</span>
                    </div>
                    <div class="stat">
                        <span class="stat-number">{}</span>
                        <span class="stat-label">Affected Files</span>
                    </div>
                    <div class="stat">
                        <span class="stat-number">{}</span>
                        <span class="stat-label">Issue Types</span>
                    </div>
                </div>
                <div class="issues-breakdown">
                    <h3>Most Common Issues</h3>
                    {}
                </div>
            </div>
        </section>"#,
        all_issues.len(),
        reports.values().filter(|r| !r.issues.is_empty()).count(),
        issue_summary.len(),
        issues_html
    )
}

fn get_issue_type_name(issue: &QualityIssue) -> String {
    match issue {
        QualityIssue::NullValues { .. } => "Null Values".to_string(),
        QualityIssue::MixedDateFormats { .. } => "Mixed Date Formats".to_string(),
        QualityIssue::Duplicates { .. } => "Duplicate Values".to_string(),
        QualityIssue::Outliers { .. } => "Outliers".to_string(),
        QualityIssue::MixedTypes { .. } => "Mixed Data Types".to_string(),
    }
}

fn format_ml_readiness_level(level: &crate::analysis::MlReadinessLevel) -> String {
    match level {
        crate::analysis::MlReadinessLevel::Ready => "Ready".to_string(),
        crate::analysis::MlReadinessLevel::Good => "Good".to_string(),
        crate::analysis::MlReadinessLevel::NeedsWork => "Needs Work".to_string(),
        crate::analysis::MlReadinessLevel::NotReady => "Not Ready".to_string(),
    }
}

/// Additional CSS for batch dashboard
fn get_batch_dashboard_css() -> &'static str {
    r#"
        .batch-summary {
            margin-bottom: 30px;
        }

        .batch-aggregated-quality-metrics {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .aggregated-intro {
            text-align: center;
            margin-bottom: 30px;
            color: #64748b;
            font-size: 1rem;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .summary-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #667eea;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .summary-card.success { border-left-color: #10b981; }
        .summary-card.warning { border-left-color: #f59e0b; }
        .summary-card.critical { border-left-color: #ef4444; }

        .card-icon {
            font-size: 2rem;
        }

        .card-content h3 {
            margin: 0 0 5px 0;
            font-size: 0.9rem;
            color: #64748b;
        }

        .metric {
            font-size: 1.8rem;
            font-weight: bold;
            color: #1e293b;
            margin: 0;
        }

        .sub-metric {
            font-size: 0.8rem;
            color: #64748b;
            margin-top: 2px;
        }

        .ml-overview {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .ml-summary-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-top: 20px;
        }

        .ml-card {
            text-align: center;
            padding: 20px;
            background: #f8fafc;
            border-radius: 10px;
        }

        .ml-score-large {
            font-size: 3rem;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
        }

        .ml-files-count {
            color: #64748b;
            font-size: 0.9rem;
        }

        .readiness-bars {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .readiness-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bar-label {
            min-width: 120px;
            font-size: 0.9rem;
            color: #64748b;
        }

        .bar {
            flex: 1;
            height: 20px;
            background: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .bar-fill.ready { background: #10b981; }
        .bar-fill.good { background: #3b82f6; }
        .bar-fill.warning { background: #f59e0b; }
        .bar-fill.critical { background: #ef4444; }

        .bar-count {
            min-width: 30px;
            text-align: right;
            font-weight: bold;
            color: #1e293b;
        }

        .files-overview {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .table-container {
            overflow-x: auto;
            margin-top: 20px;
        }

        .files-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        .files-table th {
            background: #f8fafc;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            color: #1e293b;
            border-bottom: 2px solid #e2e8f0;
        }

        .files-table td {
            padding: 15px;
            border-bottom: 1px solid #e2e8f0;
            vertical-align: middle;
        }

        .file-row {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .file-row:hover {
            background-color: #f8fafc;
        }

        .file-row.error {
            background-color: #fef2f2;
        }

        .file-name {
            font-weight: 600;
            color: #1e293b;
        }

        .file-path {
            font-size: 0.8rem;
            color: #64748b;
            margin-top: 2px;
        }

        .score-cell {
            text-align: center;
        }

        .score-badge {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .score-badge.success {
            background: #10b981;
            color: white;
        }

        .score-badge.warning {
            background: #f59e0b;
            color: white;
        }

        .score-badge.critical {
            background: #ef4444;
            color: white;
        }

        .ml-score {
            font-weight: 600;
            color: #667eea;
        }

        .details-btn {
            padding: 6px 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .details-btn:hover {
            background: #5a67d8;
        }

        .file-details {
            background: #f8fafc;
        }

        .details-content {
            padding: 20px;
        }

        .file-detail-section {
            margin-bottom: 25px;
        }

        .file-detail-section h4 {
            margin-bottom: 15px;
            color: #1e293b;
            font-size: 1.1rem;
        }

        .detail-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .ml-detail-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }

        .ml-score-display {
            text-align: center;
            padding: 20px;
            background: white;
            border-radius: 8px;
        }

        .ml-score-big {
            display: block;
            font-size: 2.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .ml-level {
            color: #64748b;
            font-size: 0.9rem;
        }

        .ml-recommendations {
            background: white;
            padding: 20px;
            border-radius: 8px;
        }

        .ml-recommendations h5 {
            margin-bottom: 10px;
            color: #1e293b;
        }

        .ml-recommendations ul {
            list-style: none;
            padding: 0;
        }

        .ml-recommendations li {
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
            color: #64748b;
        }

        .issues-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .issue-item {
            padding: 10px;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #f59e0b;
            font-size: 0.9rem;
            color: #64748b;
        }

        .aggregated-issues {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .issues-summary {
            margin-top: 20px;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat {
            text-align: center;
            padding: 20px;
            background: #f8fafc;
            border-radius: 10px;
        }

        .stat-number {
            display: block;
            font-size: 2rem;
            font-weight: bold;
            color: #1e293b;
        }

        .stat-label {
            color: #64748b;
            font-size: 0.9rem;
        }

        .issues-breakdown h3 {
            margin-bottom: 15px;
            color: #1e293b;
        }

        .issue-summary-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .issue-type {
            font-weight: 500;
            color: #1e293b;
        }

        .issue-count {
            color: #64748b;
            font-size: 0.9rem;
        }

        .error-message {
            color: #ef4444;
            font-size: 0.8rem;
        }

        @media (max-width: 768px) {
            .summary-grid {
                grid-template-columns: 1fr;
            }

            .ml-summary-grid {
                grid-template-columns: 1fr;
            }

            .ml-detail-grid {
                grid-template-columns: 1fr;
            }

            .detail-grid {
                grid-template-columns: 1fr;
            }

            .summary-stats {
                grid-template-columns: 1fr;
            }
        }
    "#
}

/// JavaScript for interactive dashboard functionality
fn get_dashboard_javascript() -> &'static str {
    r#"
        function toggleFileDetails(fileId) {
            const detailsRow = document.getElementById('details-' + fileId);
            if (detailsRow) {
                if (detailsRow.style.display === 'none' || detailsRow.style.display === '') {
                    detailsRow.style.display = 'table-row';
                } else {
                    detailsRow.style.display = 'none';
                }
            }
        }

        // Initialize any interactive features when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Add smooth scrolling to any anchor links
            const links = document.querySelectorAll('a[href^="' + '#' + '"]');
            links.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const target = document.querySelector(this.getAttribute('href'));
                    if (target) {
                        target.scrollIntoView({ behavior: 'smooth' });
                    }
                });
            });

            // Add tooltips to score badges
            const scoreBadges = document.querySelectorAll('.score-badge');
            scoreBadges.forEach(badge => {
                const score = parseFloat(badge.textContent);
                let tooltip = '';
                if (score >= 80) {
                    tooltip = 'Excellent data quality';
                } else if (score >= 60) {
                    tooltip = 'Good data quality with some issues';
                } else {
                    tooltip = 'Poor data quality - needs attention';
                }
                badge.setAttribute('title', tooltip);
            });
        });
    "#
}
